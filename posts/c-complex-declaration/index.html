<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><link rel="icon" href="/favicon.png"><title>C复杂声明 | ccat3z’s blog</title><meta name="generator" content="Jekyll v4.1.1"/><meta property="og:title" content="C复杂声明"/><meta name="author" content="ccat3z"/><meta property="og:locale" content="en_US"/><meta name="description" content="上次看到网易的gg面试题"/><meta property="og:description" content="上次看到网易的gg面试题"/><link rel="canonical" href="//ccat3z.xyz/posts/c-complex-declaration/"/><meta property="og:url" content="//ccat3z.xyz/posts/c-complex-declaration/"/><meta property="og:site_name" content="ccat3z’s blog"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2017-10-02T22:25:05+08:00"/><script type="application/ld+json">{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"//ccat3z.xyz/posts/c-complex-declaration/"},"author":{"@type":"Person","name":"ccat3z"},"headline":"C复杂声明","dateModified":"2017-10-02T22:25:05+08:00","datePublished":"2017-10-02T22:25:05+08:00","description":"上次看到网易的gg面试题","url":"//ccat3z.xyz/posts/c-complex-declaration/","@context":"https://schema.org"}</script><link href="/static/css/main.e1e213bf.chunk.css" rel="stylesheet"></head><body><div id="blog"></div><div id="blog-data"><div id="blog-data-content"><div class="post"><div class="post-info"><span class="post-id">/posts/c-complex-declaration</span> <a href="/posts/c-complex-declaration/" class="post-title">C复杂声明 </a><span class="post-date">02 Oct 2017</span><p class="post-description">上次看到网易的gg面试题</p><ul class="post-tags"><li><a href="/tag/c" class="post-tag">C</a></li></ul></div><div class="content"><p>先放大招: <a href="https://cdecl.org/">cdecl: C gibberish ↔ English</a></p><p>简单地说有如下5条规则:</p><ol><li><code class="language-plaintext highlighter-rouge">[N]</code> or <code class="language-plaintext highlighter-rouge">[]</code> 拥有N个或不确定个数元素的数组, 元素类型为…</li><li><code class="language-plaintext highlighter-rouge">(type_a, type_b)</code> 接受type_a, type_b, …参数的函数, 返回类型为…</li><li><code class="language-plaintext highlighter-rouge">*</code> 指针, 指向类型为…</li><li>优先级 <code class="language-plaintext highlighter-rouge">[]</code> &gt; <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">()</code> &gt; <code class="language-plaintext highlighter-rouge">*</code></li><li>括号永远优先</li></ol><p>看个蜜汁的例子: <code class="language-plaintext highlighter-rouge">int *(*p[])(int)</code></p><p>先从最内层看起:</p><ol><li><code class="language-plaintext highlighter-rouge">[]</code>优先级较高, <code class="language-plaintext highlighter-rouge">p[]</code>: p是一个数组, 元素的类型为…</li><li><code class="language-plaintext highlighter-rouge">*p[]</code>: 元素的类型为指针, 指向类型为…</li><li><code class="language-plaintext highlighter-rouge">()</code>优先级较高, <code class="language-plaintext highlighter-rouge">(*p[])(int)</code>: 指向类型为一个接受int的函数, 返回类型为…</li><li><code class="language-plaintext highlighter-rouge">*(*p[])(int)</code>: 返回类型为一个指针, 指向类型为…</li><li><code class="language-plaintext highlighter-rouge">int *(*p[])(int)</code>: 指向类型为int</li></ol><p>结论:</p><p>p是一个数组, 元素的类型为指针, 指向类型为一个接受int的函数, 返回类型为一个指针, 指向类型为int</p><p>这里有一篇更为详细的解释, 介绍了顺时针法, 给出了很多例子, 可以参考一下: <a href="http://c-faq.com/decl/spiral.anderson.html">Clockwise/Spiral Rule</a></p><p>不过遇到这么麻复杂的类型还是多用<code class="language-plaintext highlighter-rouge">typedef</code>吧…</p></div></div></div><div id="blog-data-page-pagination"></div><div id="blog-data-nav"><ul><li><a href="/" class="icon-home">home</a></li><li><a href="/posts/" class="icon-create">post</a></li><li><a href="/love/" class="icon-favorite">love</a></li></ul></div></div><script src="/static/js/runtime-main.89ca9b38.js"></script><script src="/static/js/2.9eda85ef.chunk.js"></script><script src="/static/js/main.c2565f73.chunk.js"></script></body></html>