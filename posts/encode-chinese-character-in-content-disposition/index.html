<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><link rel="icon" href="/favicon.png"><!-- <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"> --><!--SEO_BEGIN--><!-- Begin Jekyll SEO tag v2.7.1 --><title>解决Content-Disposition中的中文字符乱码问题 | ccat3z.xyz</title><meta name="generator" content="Jekyll v4.2.0"/><meta property="og:title" content="解决Content-Disposition中的中文字符乱码问题"/><meta name="author" content="ccat3z"/><meta property="og:locale" content="en_US"/><meta name="description" content="大部分转载正确处理下载文件时HTTP头的编码问题(Content-Disposition)"/><meta property="og:description" content="大部分转载正确处理下载文件时HTTP头的编码问题(Content-Disposition)"/><link rel="canonical" href="//ccat3z.xyz/posts/encode-chinese-character-in-content-disposition/"/><meta property="og:url" content="//ccat3z.xyz/posts/encode-chinese-character-in-content-disposition/"/><meta property="og:site_name" content="ccat3z.xyz"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2017-01-28T14:26:46+08:00"/><meta name="twitter:card" content="summary"/><meta property="twitter:title" content="解决Content-Disposition中的中文字符乱码问题"/><script type="application/ld+json">{"@type":"BlogPosting","datePublished":"2017-01-28T14:26:46+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"//ccat3z.xyz/posts/encode-chinese-character-in-content-disposition/"},"author":{"@type":"Person","name":"ccat3z"},"headline":"解决Content-Disposition中的中文字符乱码问题","dateModified":"2017-01-28T14:26:46+08:00","description":"大部分转载正确处理下载文件时HTTP头的编码问题(Content-Disposition)","url":"//ccat3z.xyz/posts/encode-chinese-character-in-content-disposition/","@context":"https://schema.org"}</script><!-- End Jekyll SEO tag --><!--SEO_END--><link href="/static/css/main.51661f66.chunk.css" rel="stylesheet"></head><body><div id="blog"></div><div id="blog-data"><div id="blog-data-content"><div class="post"><div class="post-info"><span class="post-id">/posts/encode-chinese-character-in-content-disposition</span> <a href="/posts/encode-chinese-character-in-content-disposition/" class="post-title">解决Content-Disposition中的中文字符乱码问题 </a><span class="post-date">28 Jan 2017</span><p class="post-description">大部分转载正确处理下载文件时HTTP头的编码问题(Content-Disposition)</p><ul class="post-tags"><li><a href="/tag/http/" class="post-tag">HTTP</a></li></ul></div><div class="content"><blockquote><p>大部分转载<a href="https://blog.robotshell.org/2012/deal-with-http-header-encoding-for-file-download/#comments">正确处理下载文件时HTTP头的编码问题(Content-Disposition)</a></p></blockquote><p>最近写Z Uploader的时候有这样一个Case, 下载Task的打包文件, 打算用Apache的common compress折腾完后端的TarOutputStream, 加个Content-Dispositon头交给Jersey完事. 结果上线以后发现下下来的中文名乱码. 开始以为是StringBuilder惹的锅(顺带吐槽一句Openshift的openjdk 8, 至今不知道compress完中文为什么都是??????), 尝试多种修改无果, 本来想用统一的文件名output.tar完事, 想起来可能是我两天学的HTTP不认真… 翻遍Google, 尝试各种解决GBK乱码的方法后那篇参考, 感叹以后要多读读标准…</p><p>总所周知, HTTP Header中的Content-Type可以指定内容(body)的编码, 可Header本身的编码又该如何制定? 甚至, Header究竟是否允许non-ASCII编码呢?</p><p>RFC中对于Content-Disposition是这样定义的:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Disposition: attachment;
                     filename="$encoded_fname";
                     filename*=utf-8''$encoded_fname
</code></pre></div></div><p>所谓<code class="language-plaintext highlighter-rouge">$encoded_fname</code>就是指安装百分号编码方式讲<code class="language-plaintext highlighter-rouge">UTF-8</code>字符串进行编码.</p><p>(另外, 为了兼容IE6, 请保证原始文件名必须包含英文扩展名!)</p><p>知道这点, 解决方案就变得非常简单了, 在Java里只要加上<code class="language-plaintext highlighter-rouge">URLEncoder.encode(String)</code>就行.</p><p><strong>接下来我们来看看为什么要这么做以及为什么能这么做</strong></p><p>首先, 根据<code class="language-plaintext highlighter-rouge">RFC 2616</code>所定义的HTTP 1.1协议(<code class="language-plaintext highlighter-rouge">RFC 2068</code>是最早的版本; <code class="language-plaintext highlighter-rouge">2616</code>替代了<code class="language-plaintext highlighter-rouge">2068</code>并被最广泛使用, 而后又被其他<code class="language-plaintext highlighter-rouge">RFC</code>替代, 后文将会提及), HTTP消息格式其实是基于古老的<code class="language-plaintext highlighter-rouge">ARPA Internet Text Messages</code>,而<code class="language-plaintext highlighter-rouge">ARPA</code>消息只能是<code class="language-plaintext highlighter-rouge">ASCII</code>编码的(<code class="language-plaintext highlighter-rouge">RFC 822 Section 3</code>). <code class="language-plaintext highlighter-rouge">RFC 2616 Section 2.2</code>更是再一次强调, <code class="language-plaintext highlighter-rouge">TEXT</code>(<code class="language-plaintext highlighter-rouge">Section 4.2:Header</code>中的字段值即为<code class="language-plaintext highlighter-rouge">TEXT</code>)中若要使用其他字符集, 必须使用<code class="language-plaintext highlighter-rouge">RFC 2047</code>的规则将字符串编码/逃逸-必须要注意的是, 这个规则原本是针对<code class="language-plaintext highlighter-rouge">MIME</code>(电子邮件)的扩展, 格式与百分号编码有很大不同.</p><p>在1999年<code class="language-plaintext highlighter-rouge">RFC 2616</code>推出之时, <code class="language-plaintext highlighter-rouge">Content-Dispostion</code>这个Header尚不是正式HTTP协议的一部分, 只不过是因为被广泛使用而从<code class="language-plaintext highlighter-rouge">MIME</code>标准中直接借用过来了而已(RFC 2616 Section 19.5.1). 因而几乎没有浏览器去支持<code class="language-plaintext highlighter-rouge">Content-Disposition</code>的多语言编码特性这样一个”扩展特性的扩展特性”. 事实上, <code class="language-plaintext highlighter-rouge">RFC 2616</code>中建议的使用<code class="language-plaintext highlighter-rouge">RFC 2047</code>来进行多语言编码的特性从未被主流浏览器支持过, 所以我们也不用操心上面这个<code class="language-plaintext highlighter-rouge">MIME</code>方案了…</p><p>可是这个问题却的确是现实需要的, 所以浏览器就各自想出了一些办法:</p><p>IE支持在<code class="language-plaintext highlighter-rouge">filename</code>中直接使用百分号编码: <code class="language-plaintext highlighter-rouge">filename="$encoded_text"(并非MIME编码!)</code>. 本来按照<code class="language-plaintext highlighter-rouge">RFC 2616</code>, 引号内的部分如果不是MIME编码, 则应当直接被当作内容, 就算它”看起来像是百分号编码后的字符串”; 可是IE却会”自动”对这样的文件名进行解码-前提是该文件名必须有一个不会被编码的(即ASCII)后缀名!</p><p>其他一些浏览器则支持一种更为粗暴的方式: 允许在<code class="language-plaintext highlighter-rouge">filename="TEXT"</code>中直接使用UTF-8编码的字符串! 这也是直接违反了<code class="language-plaintext highlighter-rouge">RFC 2616</code>: HTTP头必须是ASCII编码的规定.</p><p>这两类浏览器的行为是彼此互不兼容的. 所以你可以判断UA然后对IE使用前一种办法, 其他浏览器使用后一种, 这样便可以达到一般情况下能够just work的效果(Discuz就是这么做的). 不过对于Opera和Safari, 这样做可能不一定有效.</p><p>时代在进步, 2010年<code class="language-plaintext highlighter-rouge">RFC 5987</code>发布,正式规定了HTTP Header中多语言编码的处理方式采用<code class="language-plaintext highlighter-rouge">parameter*=charset'lang'value</code>的格式, 其中: <code class="language-plaintext highlighter-rouge">charset</code>和<code class="language-plaintext highlighter-rouge">lang</code>不区分大小写.</p><p><code class="language-plaintext highlighter-rouge">lang</code>是用来标注字段的语言, 以供读屏软件朗诵或根据语言特性进行特殊渲染, 可以留空.</p><p><code class="language-plaintext highlighter-rouge">value</code>根据RFC 3986 Section 2.1使用百分号编码, 并且规定浏览器至少应该支持ASCII和UTF-8.</p><p>当<code class="language-plaintext highlighter-rouge">parameter</code>和<code class="language-plaintext highlighter-rouge">parameter*</code>同时出现在HTTP头中时, 浏览器应当使用后者.</p><p>其好处是保持了向前兼容性: 一来HTTP头仍然是<code class="language-plaintext highlighter-rouge">ASCII-only</code>, 二来不支持该标准的旧版浏览器会按照当年<code class="language-plaintext highlighter-rouge">RFC 2616</code>的规定, 把<code class="language-plaintext highlighter-rouge">parameter*</code>整体当作一个<code class="language-plaintext highlighter-rouge">field name</code>, 从而当作一个未知的字段来忽略. 随后, 2011年<code class="language-plaintext highlighter-rouge">RFC 6266</code>发布, 正式将<code class="language-plaintext highlighter-rouge">Content-Disposition</code>纳入HTTP标准, 并再次强调了<code class="language-plaintext highlighter-rouge">RFC 5987</code>中多语言编码的方法, 还给出了一个范例用于解决向后兼容的问题:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Disposition: attachment;
                     filename="EURO rates";
                     filename*=utf-8''%e2%82%ac%20rates
</code></pre></div></div><p>这个例子里, <code class="language-plaintext highlighter-rouge">filename</code>的值是一个同义英语词组-这样符合<code class="language-plaintext highlighter-rouge">RFC 2616</code>, 普通的字段不应当被编码; 至于使用<code class="language-plaintext highlighter-rouge">UTF-8</code>只是因为它是标准中强制要求必须支持的. 然而, 如果我们再仔细想想-目前市场上常见的旧版本浏览器多为IE. 如此一来, 我们可以适当变通一下, 将<code class="language-plaintext highlighter-rouge">filename</code>字段也直接使用百分号编码后的字符串:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Disposition: attachment;
                     filename="%e2%82%ac%20rates.txt";
                     filename*=utf-8''%e2%82%ac%20rates.txt
</code></pre></div></div><p>对于较新的Firefox, Chrome, Opera, Safari等浏览器, 都支持并会使用新标准规定的<code class="language-plaintext highlighter-rouge">filename*</code>, 即使它们不会自动解码<code class="language-plaintext highlighter-rouge">filename</code>也无所谓了; 而对于旧版本的IE浏览器, 它们无法识别<code class="language-plaintext highlighter-rouge">filename*</code>, 会将其自动忽略并使用旧的<code class="language-plaintext highlighter-rouge">filename</code>(唯一的小瑕疵是必须要有一个英文后缀名). 这样一来就完美解决了多浏览器的多语言兼容问题, 既不需要UA判断, 也较为符合标准.</p></div></div></div><div id="blog-data-page-pagination"></div><div id="blog-data-nav"><ul><li><a href="/" class="icon-home">home</a></li><li><a href="/posts/" class="icon-create">post</a></li></ul></div></div><script>const dataElement=document.getElementById("blog-data");dataElement&&dataElement.setAttribute("style","display: none;")</script><script src="/static/js/runtime-main.26ceb475.js"></script><script src="/static/js/2.4c4b9d9d.chunk.js"></script><script src="/static/js/main.ba7c982e.chunk.js"></script></body></html>